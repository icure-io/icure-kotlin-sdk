/**
 * iCure Cloud API Documentation
 * Spring shop sample application
 *
 * OpenAPI spec version: v0.0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import io.swagger.client.models.DelegationDto
import io.swagger.client.models.DocIdentifier
import io.swagger.client.models.IcureStubDto
import io.swagger.client.models.ListOfIdsDto
import io.swagger.client.models.MessageDto
import io.swagger.client.models.MessagesReadStatusUpdate
import io.swagger.client.models.PaginatedListMessageDto

import io.swagger.client.infrastructure.*

class MessageApi(basePath: kotlin.String = "https://kraken.icure.dev") : ApiClient(basePath) {

    /**
     * Creates a message
     * 
     * @param body  
     * @return MessageDto
     */
    @Suppress("UNCHECKED_CAST")
    fun createMessage(body: MessageDto): MessageDto {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/message"
        )
        val response = request<MessageDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as MessageDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Deletes a message delegation
     * 
     * @param messageId  
     * @param delegateId  
     * @return MessageDto
     */
    @Suppress("UNCHECKED_CAST")
    fun deleteDelegation(messageId: kotlin.String, delegateId: kotlin.String): MessageDto {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.DELETE,
                "/rest/v1/message/{messageId}/delegate/{delegateId}".replace("{" + "messageId" + "}", "$messageId").replace("{" + "delegateId" + "}", "$delegateId")
        )
        val response = request<MessageDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as MessageDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Deletes multiple messages
     * 
     * @param messageIds  
     * @return kotlin.Array<DocIdentifier>
     */
    @Suppress("UNCHECKED_CAST")
    fun deleteMessages(messageIds: kotlin.String): kotlin.Array<DocIdentifier> {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.DELETE,
                "/rest/v1/message/{messageIds}".replace("{" + "messageIds" + "}", "$messageIds")
        )
        val response = request<kotlin.Array<DocIdentifier>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<DocIdentifier>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Deletes multiple messages
     * 
     * @param body  
     * @return kotlin.Array<DocIdentifier>
     */
    @Suppress("UNCHECKED_CAST")
    fun deleteMessagesBatch(body: ListOfIdsDto): kotlin.Array<DocIdentifier> {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/message/delete/byIds"
        )
        val response = request<kotlin.Array<DocIdentifier>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<DocIdentifier>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get all messages (paginated) for current HC Party
     * 
     * @param startKey  (optional)
     * @param startDocumentId  (optional)
     * @param limit  (optional)
     * @return PaginatedListMessageDto
     */
    @Suppress("UNCHECKED_CAST")
    fun findMessages(startKey: kotlin.String? = null, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null): PaginatedListMessageDto {
        val localVariableQuery: MultiValueMap = mapOf("startKey" to listOf("$startKey"), "startDocumentId" to listOf("$startDocumentId"), "limit" to listOf("$limit"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/message", query = localVariableQuery
        )
        val response = request<PaginatedListMessageDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as PaginatedListMessageDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get all messages (paginated) for current HC Party and provided from address
     * 
     * @param fromAddress  (optional)
     * @param startKey  (optional)
     * @param startDocumentId  (optional)
     * @param limit  (optional)
     * @param hcpId  (optional)
     * @return PaginatedListMessageDto
     */
    @Suppress("UNCHECKED_CAST")
    fun findMessagesByFromAddress(fromAddress: kotlin.String? = null, startKey: kotlin.String? = null, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null, hcpId: kotlin.String? = null): PaginatedListMessageDto {
        val localVariableQuery: MultiValueMap = mapOf("fromAddress" to listOf("$fromAddress"), "startKey" to listOf("$startKey"), "startDocumentId" to listOf("$startDocumentId"), "limit" to listOf("$limit"), "hcpId" to listOf("$hcpId"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/message/byFromAddress", query = localVariableQuery
        )
        val response = request<PaginatedListMessageDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as PaginatedListMessageDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * List messages found By Healthcare Party and secret foreign keys.
     * Keys must be delimited by coma
     * @param secretFKeys  
     * @return kotlin.Array<MessageDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun findMessagesByHCPartyPatientForeignKeys(secretFKeys: kotlin.String): kotlin.Array<MessageDto> {
        val localVariableQuery: MultiValueMap = mapOf("secretFKeys" to listOf("$secretFKeys"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/message/byHcPartySecretForeignKeys", query = localVariableQuery
        )
        val response = request<kotlin.Array<MessageDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<MessageDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get all messages (paginated) for current HC Party and provided to address
     * 
     * @param toAddress  (optional)
     * @param startKey  (optional)
     * @param startDocumentId  (optional)
     * @param limit  (optional)
     * @param reverse  (optional)
     * @param hcpId  (optional)
     * @return PaginatedListMessageDto
     */
    @Suppress("UNCHECKED_CAST")
    fun findMessagesByToAddress(toAddress: kotlin.String? = null, startKey: kotlin.String? = null, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null, reverse: kotlin.Boolean? = null, hcpId: kotlin.String? = null): PaginatedListMessageDto {
        val localVariableQuery: MultiValueMap = mapOf("toAddress" to listOf("$toAddress"), "startKey" to listOf("$startKey"), "startDocumentId" to listOf("$startDocumentId"), "limit" to listOf("$limit"), "reverse" to listOf("$reverse"), "hcpId" to listOf("$hcpId"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/message/byToAddress", query = localVariableQuery
        )
        val response = request<PaginatedListMessageDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as PaginatedListMessageDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get all messages (paginated) for current HC Party and provided transportGuid
     * 
     * @param transportGuid  (optional)
     * @param received  (optional)
     * @param startKey  (optional)
     * @param startDocumentId  (optional)
     * @param limit  (optional)
     * @param hcpId  (optional)
     * @return PaginatedListMessageDto
     */
    @Suppress("UNCHECKED_CAST")
    fun findMessagesByTransportGuid(transportGuid: kotlin.String? = null, received: kotlin.Boolean? = null, startKey: kotlin.String? = null, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null, hcpId: kotlin.String? = null): PaginatedListMessageDto {
        val localVariableQuery: MultiValueMap = mapOf("transportGuid" to listOf("$transportGuid"), "received" to listOf("$received"), "startKey" to listOf("$startKey"), "startDocumentId" to listOf("$startDocumentId"), "limit" to listOf("$limit"), "hcpId" to listOf("$hcpId"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/message/byTransportGuid", query = localVariableQuery
        )
        val response = request<PaginatedListMessageDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as PaginatedListMessageDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get all messages starting by a prefix between two date
     * 
     * @param from  (optional)
     * @param to  (optional)
     * @param transportGuid  (optional)
     * @param startKey  (optional)
     * @param startDocumentId  (optional)
     * @param limit  (optional)
     * @param hcpId  (optional)
     * @return PaginatedListMessageDto
     */
    @Suppress("UNCHECKED_CAST")
    fun findMessagesByTransportGuidSentDate(from: kotlin.Long? = null, to: kotlin.Long? = null, transportGuid: kotlin.String? = null, startKey: kotlin.String? = null, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null, hcpId: kotlin.String? = null): PaginatedListMessageDto {
        val localVariableQuery: MultiValueMap = mapOf("from" to listOf("$from"), "to" to listOf("$to"), "transportGuid" to listOf("$transportGuid"), "startKey" to listOf("$startKey"), "startDocumentId" to listOf("$startDocumentId"), "limit" to listOf("$limit"), "hcpId" to listOf("$hcpId"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/message/byTransportGuidSentDate", query = localVariableQuery
        )
        val response = request<PaginatedListMessageDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as PaginatedListMessageDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get children messages of provided message
     * 
     * @param messageId  
     * @return kotlin.Array<MessageDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun getChildrenMessages(messageId: kotlin.String): kotlin.Array<MessageDto> {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/message/{messageId}/children".replace("{" + "messageId" + "}", "$messageId")
        )
        val response = request<kotlin.Array<MessageDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<MessageDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get children messages of provided message
     * 
     * @param body  
     * @return kotlin.Array<MessageDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun getChildrenMessagesOfList(body: ListOfIdsDto): kotlin.Array<MessageDto> {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/message/children/batch"
        )
        val response = request<kotlin.Array<MessageDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<MessageDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Gets a message
     * 
     * @param messageId  
     * @return MessageDto
     */
    @Suppress("UNCHECKED_CAST")
    fun getMessage(messageId: kotlin.String): MessageDto {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/message/{messageId}".replace("{" + "messageId" + "}", "$messageId")
        )
        val response = request<MessageDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as MessageDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get children messages of provided message
     * 
     * @param body  
     * @return kotlin.Array<MessageDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun listMessagesByInvoiceIds(body: ListOfIdsDto): kotlin.Array<MessageDto> {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/message/byInvoiceId"
        )
        val response = request<kotlin.Array<MessageDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<MessageDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Updates a message
     * 
     * @param body  
     * @return MessageDto
     */
    @Suppress("UNCHECKED_CAST")
    fun modifyMessage(body: MessageDto): MessageDto {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/rest/v1/message"
        )
        val response = request<MessageDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as MessageDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Adds a delegation to a message
     * 
     * @param body  
     * @param messageId  
     * @return IcureStubDto
     */
    @Suppress("UNCHECKED_CAST")
    fun newMessageDelegations(body: kotlin.Array<DelegationDto>, messageId: kotlin.String): IcureStubDto {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/rest/v1/message/{messageId}/delegate".replace("{" + "messageId" + "}", "$messageId")
        )
        val response = request<IcureStubDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as IcureStubDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Set read status for given list of messages
     * 
     * @param body  
     * @return kotlin.Array<MessageDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun setMessagesReadStatus(body: MessagesReadStatusUpdate): kotlin.Array<MessageDto> {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/rest/v1/message/readstatus"
        )
        val response = request<kotlin.Array<MessageDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<MessageDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Set status bits for given list of messages
     * 
     * @param body  
     * @param status  
     * @return kotlin.Array<MessageDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun setMessagesStatusBits(body: ListOfIdsDto, status: kotlin.Int): kotlin.Array<MessageDto> {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/rest/v1/message/status/{status}".replace("{" + "status" + "}", "$status")
        )
        val response = request<kotlin.Array<MessageDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<MessageDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
}
