/**
 * iCure Cloud API Documentation
 * Spring shop sample application
 *
 * OpenAPI spec version: v0.0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import io.swagger.client.models.DelegationDto
import io.swagger.client.models.DocIdentifier
import io.swagger.client.models.FilterChainHealthElement
import io.swagger.client.models.HealthElementDto
import io.swagger.client.models.IcureStubDto

import io.swagger.client.infrastructure.*

class HelementApi(basePath: kotlin.String = "https://kraken.icure.dev") : ApiClient(basePath) {

    /**
     * Create a health element with the current user
     * Returns an instance of created health element.
     * @param body  
     * @return HealthElementDto
     */
    @Suppress("UNCHECKED_CAST")
    fun createHealthElement(body: HealthElementDto): HealthElementDto {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/helement"
        )
        val response = request<HealthElementDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as HealthElementDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Delete health elements.
     * Response is a set containing the ID&#x27;s of deleted health elements.
     * @param healthElementIds  
     * @return kotlin.Array<DocIdentifier>
     */
    @Suppress("UNCHECKED_CAST")
    fun deleteHealthElements(healthElementIds: kotlin.String): kotlin.Array<DocIdentifier> {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.DELETE,
                "/rest/v1/helement/{healthElementIds}".replace("{" + "healthElementIds" + "}", "$healthElementIds")
        )
        val response = request<kotlin.Array<DocIdentifier>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<DocIdentifier>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Filter health elements for the current user (HcParty)
     * Returns a list of health elements along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.
     * @param body  
     * @return kotlin.Array<HealthElementDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun filterHealthElementsBy(body: FilterChainHealthElement): kotlin.Array<HealthElementDto> {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/helement/filter"
        )
        val response = request<kotlin.Array<HealthElementDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<HealthElementDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * List health elements found By Healthcare Party and secret foreign keyelementIds.
     * Keys hast to delimited by coma
     * @param hcPartyId  
     * @param secretFKeys  
     * @return kotlin.Array<HealthElementDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun findHealthElementsByHCPartyPatientForeignKeys(hcPartyId: kotlin.String, secretFKeys: kotlin.String): kotlin.Array<HealthElementDto> {
        val localVariableQuery: MultiValueMap = mapOf("hcPartyId" to listOf("$hcPartyId"), "secretFKeys" to listOf("$secretFKeys"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/helement/byHcPartySecretForeignKeys", query = localVariableQuery
        )
        val response = request<kotlin.Array<HealthElementDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<HealthElementDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * List helement stubs found By Healthcare Party and secret foreign keys.
     * Keys must be delimited by coma
     * @param hcPartyId  
     * @param secretFKeys  
     * @return kotlin.Array<IcureStubDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun findHealthElementsDelegationsStubsByHCPartyPatientForeignKeys(hcPartyId: kotlin.String, secretFKeys: kotlin.String): kotlin.Array<IcureStubDto> {
        val localVariableQuery: MultiValueMap = mapOf("hcPartyId" to listOf("$hcPartyId"), "secretFKeys" to listOf("$secretFKeys"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/helement/byHcPartySecretForeignKeys/delegations", query = localVariableQuery
        )
        val response = request<kotlin.Array<IcureStubDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<IcureStubDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get a health element
     * 
     * @param healthElementId  
     * @return HealthElementDto
     */
    @Suppress("UNCHECKED_CAST")
    fun getHealthElement(healthElementId: kotlin.String): HealthElementDto {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/helement/{healthElementId}".replace("{" + "healthElementId" + "}", "$healthElementId")
        )
        val response = request<HealthElementDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as HealthElementDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Modify a health element
     * Returns the modified health element.
     * @param body  
     * @return HealthElementDto
     */
    @Suppress("UNCHECKED_CAST")
    fun modifyHealthElement(body: HealthElementDto): HealthElementDto {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/rest/v1/helement"
        )
        val response = request<HealthElementDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as HealthElementDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Modify a batch of health elements
     * Returns the modified health elements.
     * @param body  
     * @return kotlin.Array<HealthElementDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun modifyHealthElements(body: kotlin.Array<HealthElementDto>): kotlin.Array<HealthElementDto> {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/rest/v1/helement/batch"
        )
        val response = request<kotlin.Array<HealthElementDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<HealthElementDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Delegates a health element to a healthcare party
     * It delegates a health element to a healthcare party (By current healthcare party). Returns the element with new delegations.
     * @param body  
     * @param healthElementId  
     * @return HealthElementDto
     */
    @Suppress("UNCHECKED_CAST")
    fun newHealthElementDelegations(body: kotlin.Array<DelegationDto>, healthElementId: kotlin.String): HealthElementDto {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/helement/{healthElementId}/delegate".replace("{" + "healthElementId" + "}", "$healthElementId")
        )
        val response = request<HealthElementDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as HealthElementDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Update delegations in healthElements.
     * Keys must be delimited by coma
     * @param body  
     * @return kotlin.Array<HealthElementDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun setHealthElementsDelegations(body: kotlin.Array<IcureStubDto>): kotlin.Array<HealthElementDto> {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/helement/delegations"
        )
        val response = request<kotlin.Array<HealthElementDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<HealthElementDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
}
