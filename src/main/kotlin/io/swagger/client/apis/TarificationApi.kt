/**
 * iCure Cloud API Documentation
 * Spring shop sample application
 *
 * OpenAPI spec version: v0.0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import io.swagger.client.models.ListOfIdsDto
import io.swagger.client.models.PaginatedListTarificationDto
import io.swagger.client.models.TarificationDto

import io.swagger.client.infrastructure.*

class TarificationApi(basePath: kotlin.String = "https://kraken.icure.dev") : ApiClient(basePath) {

    /**
     * Create a Tarification
     * Type, Tarification and Version are required.
     * @param body  
     * @return TarificationDto
     */
    @Suppress("UNCHECKED_CAST")
    fun createTarification(body: TarificationDto): TarificationDto {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/tarification"
        )
        val response = request<TarificationDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TarificationDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Finding tarifications by tarification, type and version with pagination.
     * Returns a list of tarifications matched with given input.
     * @param region  (optional)
     * @param type  (optional)
     * @param tarification  (optional)
     * @param version  (optional)
     * @param startDocumentId A tarification document ID (optional)
     * @param limit Number of rows (optional)
     * @return PaginatedListTarificationDto
     */
    @Suppress("UNCHECKED_CAST")
    fun findPaginatedTarifications(region: kotlin.String? = null, type: kotlin.String? = null, tarification: kotlin.String? = null, version: kotlin.String? = null, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null): PaginatedListTarificationDto {
        val localVariableQuery: MultiValueMap = mapOf("region" to listOf("$region"), "type" to listOf("$type"), "tarification" to listOf("$tarification"), "version" to listOf("$version"), "startDocumentId" to listOf("$startDocumentId"), "limit" to listOf("$limit"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/tarification", query = localVariableQuery
        )
        val response = request<PaginatedListTarificationDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as PaginatedListTarificationDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Finding tarifications by tarification, type and version with pagination.
     * Returns a list of tarifications matched with given input.
     * @param region  (optional)
     * @param types  (optional)
     * @param language  (optional)
     * @param label  (optional)
     * @param startDocumentId A tarification document ID (optional)
     * @param limit Number of rows (optional)
     * @return PaginatedListTarificationDto
     */
    @Suppress("UNCHECKED_CAST")
    fun findPaginatedTarificationsByLabel(region: kotlin.String? = null, types: kotlin.String? = null, language: kotlin.String? = null, label: kotlin.String? = null, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null): PaginatedListTarificationDto {
        val localVariableQuery: MultiValueMap = mapOf("region" to listOf("$region"), "types" to listOf("$types"), "language" to listOf("$language"), "label" to listOf("$label"), "startDocumentId" to listOf("$startDocumentId"), "limit" to listOf("$limit"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/tarification/byLabel", query = localVariableQuery
        )
        val response = request<PaginatedListTarificationDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as PaginatedListTarificationDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Finding tarifications by tarification, type and version
     * Returns a list of tarifications matched with given input.
     * @param region Tarification region (optional)
     * @param type Tarification type (optional)
     * @param tarification Tarification tarification (optional)
     * @param version Tarification version (optional)
     * @return kotlin.Array<TarificationDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun findTarifications(region: kotlin.String? = null, type: kotlin.String? = null, tarification: kotlin.String? = null, version: kotlin.String? = null): kotlin.Array<TarificationDto> {
        val localVariableQuery: MultiValueMap = mapOf("region" to listOf("$region"), "type" to listOf("$type"), "tarification" to listOf("$tarification"), "version" to listOf("$version"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/tarification/byRegionTypeTarification", query = localVariableQuery
        )
        val response = request<kotlin.Array<TarificationDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<TarificationDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get a tarification
     * Get a tarification based on ID or (tarification,type,version) as query strings. (tarification,type,version) is unique.
     * @param tarificationId Tarification id 
     * @return TarificationDto
     */
    @Suppress("UNCHECKED_CAST")
    fun getTarification(tarificationId: kotlin.String): TarificationDto {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/tarification/{tarificationId}".replace("{" + "tarificationId" + "}", "$tarificationId")
        )
        val response = request<TarificationDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TarificationDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get a tarification
     * Get a tarification based on ID or (tarification,type,version) as query strings. (tarification,type,version) is unique.
     * @param type Tarification type 
     * @param tarification Tarification tarification 
     * @param version Tarification version 
     * @return TarificationDto
     */
    @Suppress("UNCHECKED_CAST")
    fun getTarificationWithParts(type: kotlin.String, tarification: kotlin.String, version: kotlin.String): TarificationDto {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/tarification/{type}/{tarification}/{version}".replace("{" + "type" + "}", "$type").replace("{" + "tarification" + "}", "$tarification").replace("{" + "version" + "}", "$version")
        )
        val response = request<TarificationDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TarificationDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get a list of tarifications by ids
     * Keys must be delimited by coma
     * @param body  
     * @return kotlin.Array<TarificationDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun getTarifications(body: ListOfIdsDto): kotlin.Array<TarificationDto> {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/tarification/byIds"
        )
        val response = request<kotlin.Array<TarificationDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<TarificationDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Modify a tarification
     * Modification of (type, tarification, version) is not allowed.
     * @param body  
     * @return TarificationDto
     */
    @Suppress("UNCHECKED_CAST")
    fun modifyTarification(body: TarificationDto): TarificationDto {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/rest/v1/tarification"
        )
        val response = request<TarificationDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TarificationDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
}
