/**
 * iCure Cloud API Documentation
 * Spring shop sample application
 *
 * OpenAPI spec version: v0.0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import io.swagger.client.models.AbstractFilterDtoContact
import io.swagger.client.models.ContactDto
import io.swagger.client.models.ContentDto
import io.swagger.client.models.DelegationDto
import io.swagger.client.models.DocIdentifier
import io.swagger.client.models.FilterChainContact
import io.swagger.client.models.FilterChainService
import io.swagger.client.models.IcureStubDto
import io.swagger.client.models.LabelledOccurenceDto
import io.swagger.client.models.ListOfIdsDto
import io.swagger.client.models.PaginatedListContactDto
import io.swagger.client.models.PaginatedListServiceDto

import io.swagger.client.infrastructure.*

class ContactApi(basePath: kotlin.String = "https://kraken.icure.dev") : ApiClient(basePath) {

    /**
     * Close contacts for Healthcare Party and secret foreign keys.
     * Keys must be delimited by coma
     * @param hcPartyId  
     * @param secretFKeys  
     * @return kotlin.Array<ContactDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun closeForHCPartyPatientForeignKeys(hcPartyId: kotlin.String, secretFKeys: kotlin.String): kotlin.Array<ContactDto> {
        val localVariableQuery: MultiValueMap = mapOf("hcPartyId" to listOf("$hcPartyId"), "secretFKeys" to listOf("$secretFKeys"))
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/rest/v1/contact/byHcPartySecretForeignKeys/close", query = localVariableQuery
        )
        val response = request<kotlin.Array<ContactDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<ContactDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Create a contact with the current user
     * Returns an instance of created contact.
     * @param body  
     * @return ContactDto
     */
    @Suppress("UNCHECKED_CAST")
    fun createContact(body: ContactDto): ContactDto {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/contact"
        )
        val response = request<ContactDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ContactDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Delete contacts.
     * Response is a set containing the ID&#x27;s of deleted contacts.
     * @param contactIds  
     * @return kotlin.Array<DocIdentifier>
     */
    @Suppress("UNCHECKED_CAST")
    fun deleteContacts(contactIds: kotlin.String): kotlin.Array<DocIdentifier> {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.DELETE,
                "/rest/v1/contact/{contactIds}".replace("{" + "contactIds" + "}", "$contactIds")
        )
        val response = request<kotlin.Array<DocIdentifier>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<DocIdentifier>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * List contacts for the current user (HcParty) or the given hcparty in the filter 
     * Returns a list of contacts along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.
     * @param body  
     * @param startDocumentId A Contact document ID (optional)
     * @param limit Number of rows (optional)
     * @return PaginatedListContactDto
     */
    @Suppress("UNCHECKED_CAST")
    fun filterContactsBy(body: FilterChainContact, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null): PaginatedListContactDto {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("startDocumentId" to listOf("$startDocumentId"), "limit" to listOf("$limit"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/contact/filter", query = localVariableQuery
        )
        val response = request<PaginatedListContactDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as PaginatedListContactDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * List services for the current user (HcParty) or the given hcparty in the filter 
     * Returns a list of contacts along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.
     * @param body  
     * @param startDocumentId A Contact document ID (optional)
     * @param limit Number of rows (optional)
     * @return PaginatedListServiceDto
     */
    @Suppress("UNCHECKED_CAST")
    fun filterServicesBy(body: FilterChainService, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null): PaginatedListServiceDto {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("startDocumentId" to listOf("$startDocumentId"), "limit" to listOf("$limit"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/contact/service/filter", query = localVariableQuery
        )
        val response = request<PaginatedListServiceDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as PaginatedListServiceDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * List contacts found By Healthcare Party and form Id.
     * 
     * @param hcPartyId  
     * @param formId  
     * @return kotlin.Array<ContactDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun findByHCPartyFormId(hcPartyId: kotlin.String, formId: kotlin.String): kotlin.Array<ContactDto> {
        val localVariableQuery: MultiValueMap = mapOf("hcPartyId" to listOf("$hcPartyId"), "formId" to listOf("$formId"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/contact/byHcPartyFormId", query = localVariableQuery
        )
        val response = request<kotlin.Array<ContactDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<ContactDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * List contacts found By Healthcare Party and form Id.
     * 
     * @param body  
     * @param hcPartyId  
     * @return kotlin.Array<ContactDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun findByHCPartyFormIds(body: ListOfIdsDto, hcPartyId: kotlin.String): kotlin.Array<ContactDto> {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("hcPartyId" to listOf("$hcPartyId"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/contact/byHcPartyFormIds", query = localVariableQuery
        )
        val response = request<kotlin.Array<ContactDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<ContactDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * List contacts found By Healthcare Party and secret foreign keys.
     * Keys must be delimited by coma
     * @param hcPartyId  
     * @param secretFKeys  
     * @param planOfActionsIds  (optional)
     * @param skipClosedContacts  (optional)
     * @return kotlin.Array<ContactDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun findByHCPartyPatientSecretFKeys(hcPartyId: kotlin.String, secretFKeys: kotlin.String, planOfActionsIds: kotlin.String? = null, skipClosedContacts: kotlin.Boolean? = null): kotlin.Array<ContactDto> {
        val localVariableQuery: MultiValueMap = mapOf("hcPartyId" to listOf("$hcPartyId"), "secretFKeys" to listOf("$secretFKeys"), "planOfActionsIds" to listOf("$planOfActionsIds"), "skipClosedContacts" to listOf("$skipClosedContacts"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/contact/byHcPartySecretForeignKeys", query = localVariableQuery
        )
        val response = request<kotlin.Array<ContactDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<ContactDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * List contacts found By Healthcare Party and Patient foreign keys.
     * 
     * @param body  
     * @param hcPartyId  
     * @return kotlin.Array<ContactDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun findContactsByHCPartyPatientForeignKeys(body: ListOfIdsDto, hcPartyId: kotlin.String): kotlin.Array<ContactDto> {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("hcPartyId" to listOf("$hcPartyId"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/contact/byHcPartyPatientForeignKeys", query = localVariableQuery
        )
        val response = request<kotlin.Array<ContactDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<ContactDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * List contacts found By Healthcare Party and secret foreign keys.
     * Keys must be delimited by coma
     * @param hcPartyId  
     * @param secretFKeys  
     * @return kotlin.Array<IcureStubDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun findContactsDelegationsStubsByHCPartyPatientForeignKeys(hcPartyId: kotlin.String, secretFKeys: kotlin.String): kotlin.Array<IcureStubDto> {
        val localVariableQuery: MultiValueMap = mapOf("hcPartyId" to listOf("$hcPartyId"), "secretFKeys" to listOf("$secretFKeys"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/contact/byHcPartySecretForeignKeys/delegations", query = localVariableQuery
        )
        val response = request<kotlin.Array<IcureStubDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<IcureStubDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get a contact
     * 
     * @param contactId  
     * @return ContactDto
     */
    @Suppress("UNCHECKED_CAST")
    fun getContact(contactId: kotlin.String): ContactDto {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/contact/{contactId}".replace("{" + "contactId" + "}", "$contactId")
        )
        val response = request<ContactDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ContactDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get contacts
     * 
     * @param body  
     * @return kotlin.Array<ContactDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun getContacts(body: ListOfIdsDto): kotlin.Array<ContactDto> {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/contact/byIds"
        )
        val response = request<kotlin.Array<ContactDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<ContactDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get an empty content
     * 
     * @return ContentDto
     */
    @Suppress("UNCHECKED_CAST")
    fun getEmptyContent(): ContentDto {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/contact/service/content/empty"
        )
        val response = request<ContentDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ContentDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get the list of all used codes frequencies in services
     * 
     * @param codeType  
     * @param minOccurences  
     * @return kotlin.Array<LabelledOccurenceDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun getServiceCodesOccurences(codeType: kotlin.String, minOccurences: kotlin.Long): kotlin.Array<LabelledOccurenceDto> {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/contact/service/codes/{codeType}/{minOccurences}".replace("{" + "codeType" + "}", "$codeType").replace("{" + "minOccurences" + "}", "$minOccurences")
        )
        val response = request<kotlin.Array<LabelledOccurenceDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<LabelledOccurenceDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * List contacts bu opening date parties with(out) pagination
     * Returns a list of contacts.
     * @param startKey The contact openingDate 
     * @param endKey The contact max openingDate 
     * @param hcpartyid hcpartyid 
     * @param startDocumentId A contact party document ID (optional)
     * @param limit Number of rows (optional)
     * @return PaginatedListContactDto
     */
    @Suppress("UNCHECKED_CAST")
    fun listContactsByOpeningDate(startKey: kotlin.Long, endKey: kotlin.Long, hcpartyid: kotlin.String, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null): PaginatedListContactDto {
        val localVariableQuery: MultiValueMap = mapOf("startKey" to listOf("$startKey"), "endKey" to listOf("$endKey"), "hcpartyid" to listOf("$hcpartyid"), "startDocumentId" to listOf("$startDocumentId"), "limit" to listOf("$limit"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/contact/byOpeningDate", query = localVariableQuery
        )
        val response = request<PaginatedListContactDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as PaginatedListContactDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get ids of contacts matching the provided filter for the current user (HcParty) 
     * 
     * @param body  
     * @return kotlin.Array<kotlin.String>
     */
    @Suppress("UNCHECKED_CAST")
    fun matchContactsBy(body: AbstractFilterDtoContact): kotlin.Array<kotlin.String> {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/contact/match"
        )
        val response = request<kotlin.Array<kotlin.String>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<kotlin.String>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Modify a contact
     * Returns the modified contact.
     * @param body  
     * @return ContactDto
     */
    @Suppress("UNCHECKED_CAST")
    fun modifyContact(body: ContactDto): ContactDto {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/rest/v1/contact"
        )
        val response = request<ContactDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ContactDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Modify a batch of contacts
     * Returns the modified contacts.
     * @param body  
     * @return kotlin.Array<ContactDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun modifyContacts(body: kotlin.Array<ContactDto>): kotlin.Array<ContactDto> {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/rest/v1/contact/batch"
        )
        val response = request<kotlin.Array<ContactDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<ContactDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Delegates a contact to a healthcare party
     * It delegates a contact to a healthcare party (By current healthcare party). Returns the contact with new delegations.
     * @param body  
     * @param contactId  
     * @return ContactDto
     */
    @Suppress("UNCHECKED_CAST")
    fun newContactDelegations(body: DelegationDto, contactId: kotlin.String): ContactDto {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/contact/{contactId}/delegate".replace("{" + "contactId" + "}", "$contactId")
        )
        val response = request<ContactDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ContactDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Update delegations in healthElements.
     * Keys must be delimited by coma
     * @param body  
     * @return kotlin.Array<ContactDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun setContactsDelegations(body: kotlin.Array<IcureStubDto>): kotlin.Array<ContactDto> {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/contact/delegations"
        )
        val response = request<kotlin.Array<ContactDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<ContactDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
}
