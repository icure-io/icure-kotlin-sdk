/**
 * iCure Cloud API Documentation
 * Spring shop sample application
 *
 * OpenAPI spec version: v0.0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import io.swagger.client.models.AccessLogDto
import io.swagger.client.models.DocIdentifier
import io.swagger.client.models.PaginatedListAccessLogDto

import io.swagger.client.infrastructure.*

class AccesslogApi(basePath: kotlin.String = "https://kraken.icure.dev") : ApiClient(basePath) {

    /**
     * Creates an access log
     * 
     * @param body  
     * @return AccessLogDto
     */
    @Suppress("UNCHECKED_CAST")
    fun createAccessLog(body: AccessLogDto): AccessLogDto {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/accesslog"
        )
        val response = request<AccessLogDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AccessLogDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Deletes an access log
     * 
     * @param accessLogIds  
     * @return kotlin.Array<DocIdentifier>
     */
    @Suppress("UNCHECKED_CAST")
    fun deleteAccessLog(accessLogIds: kotlin.String): kotlin.Array<DocIdentifier> {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.DELETE,
                "/rest/v1/accesslog/{accessLogIds}".replace("{" + "accessLogIds" + "}", "$accessLogIds")
        )
        val response = request<kotlin.Array<DocIdentifier>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<DocIdentifier>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * List access logs found By Healthcare Party and secret foreign keyelementIds.
     * 
     * @param hcPartyId  
     * @param secretFKeys  
     * @return kotlin.Array<AccessLogDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun findAccessLogsByHCPartyPatientForeignKeys(hcPartyId: kotlin.String, secretFKeys: kotlin.String): kotlin.Array<AccessLogDto> {
        val localVariableQuery: MultiValueMap = mapOf("hcPartyId" to listOf("$hcPartyId"), "secretFKeys" to listOf("$secretFKeys"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/accesslog/byHcPartySecretForeignKeys", query = localVariableQuery
        )
        val response = request<kotlin.Array<AccessLogDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<AccessLogDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get Paginated List of Access logs
     * 
     * @param userId A User ID 
     * @param accessType The type of access (COMPUTER or USER) (optional)
     * @param startDate The start search epoch (optional)
     * @param startKey The start key for pagination (optional)
     * @param startDocumentId A patient document ID (optional)
     * @param limit Number of rows (optional)
     * @param descending Descending order (optional)
     * @return PaginatedListAccessLogDto
     */
    @Suppress("UNCHECKED_CAST")
    fun findByUserAfterDate(userId: kotlin.String, accessType: kotlin.String? = null, startDate: kotlin.Long? = null, startKey: kotlin.String? = null, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null, descending: kotlin.Boolean? = null): PaginatedListAccessLogDto {
        val localVariableQuery: MultiValueMap = mapOf("userId" to listOf("$userId"), "accessType" to listOf("$accessType"), "startDate" to listOf("$startDate"), "startKey" to listOf("$startKey"), "startDocumentId" to listOf("$startDocumentId"), "limit" to listOf("$limit"), "descending" to listOf("$descending"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/accesslog/byUser", query = localVariableQuery
        )
        val response = request<PaginatedListAccessLogDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as PaginatedListAccessLogDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Gets an access log
     * 
     * @param accessLogId  
     * @return AccessLogDto
     */
    @Suppress("UNCHECKED_CAST")
    fun getAccessLog(accessLogId: kotlin.String): AccessLogDto {
        
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/accesslog/{accessLogId}".replace("{" + "accessLogId" + "}", "$accessLogId")
        )
        val response = request<AccessLogDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AccessLogDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Lists access logs
     * 
     * @param fromEpoch  (optional)
     * @param toEpoch  (optional)
     * @param startKey  (optional)
     * @param startDocumentId  (optional)
     * @param limit  (optional)
     * @param descending  (optional)
     * @return PaginatedListAccessLogDto
     */
    @Suppress("UNCHECKED_CAST")
    fun listAccessLogs(fromEpoch: kotlin.Long? = null, toEpoch: kotlin.Long? = null, startKey: kotlin.Long? = null, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null, descending: kotlin.Boolean? = null): PaginatedListAccessLogDto {
        val localVariableQuery: MultiValueMap = mapOf("fromEpoch" to listOf("$fromEpoch"), "toEpoch" to listOf("$toEpoch"), "startKey" to listOf("$startKey"), "startDocumentId" to listOf("$startDocumentId"), "limit" to listOf("$limit"), "descending" to listOf("$descending"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/accesslog", query = localVariableQuery
        )
        val response = request<PaginatedListAccessLogDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as PaginatedListAccessLogDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Modifies an access log
     * 
     * @param body  
     * @return AccessLogDto
     */
    @Suppress("UNCHECKED_CAST")
    fun modifyAccessLog(body: AccessLogDto): AccessLogDto {
        val localVariableBody: kotlin.Any? = body
        
        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/rest/v1/accesslog"
        )
        val response = request<AccessLogDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AccessLogDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
}
