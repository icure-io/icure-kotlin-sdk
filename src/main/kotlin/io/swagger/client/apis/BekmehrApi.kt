/**
 * iCure Cloud API Documentation
 * Spring shop sample application
 *
 * OpenAPI spec version: v0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis


import io.swagger.client.models.CheckSMFPatientResult
import io.swagger.client.models.ContentDto
import io.swagger.client.models.DiaryNoteExportInfoDto
import io.swagger.client.models.ImportMapping
import io.swagger.client.models.ImportResultDto
import io.swagger.client.models.MedicationSchemeExportInfoDto
import io.swagger.client.models.SoftwareMedicalFileExportDto
import io.swagger.client.models.SumehrContentDto
import io.swagger.client.models.SumehrExportInfoDto
import io.swagger.client.models.SumehrValidityDto

import io.swagger.client.infrastructure.*

class BekmehrApi(basePath: kotlin.String = "https://kraken.icure.dev") : ApiClient(basePath) {

    /**
     * Check whether patients in SMF already exists in DB
     *
     * @param body
     * @param documentId
     * @param documentKey  (optional)
     * @param patientId  (optional)
     * @param language  (optional)
     * @return kotlin.Array<CheckSMFPatientResult>
     */
    @Suppress("UNCHECKED_CAST")
    fun checkIfSMFPatientsExists(body: kotlin.collections.Map<kotlin.String, kotlin.Array<ImportMapping>>, documentId: kotlin.String, documentKey: kotlin.String? = null, patientId: kotlin.String? = null, language: kotlin.String? = null): kotlin.Array<CheckSMFPatientResult> {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("documentKey" to listOf("$documentKey"), "patientId" to listOf("$patientId"), "language" to listOf("$language"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/be_kmehr/smf/{documentId}/checkIfSMFPatientsExists".replace("{" + "documentId" + "}", "$documentId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<CheckSMFPatientResult>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<CheckSMFPatientResult>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get Kmehr contactreport
     *
     * @param body
     * @param date
     * @param language
     * @param recipientNihii
     * @param recipientSsin
     * @param recipientFirstName
     * @param recipientLastName
     * @param mimeType
     * @param patientId
     * @param id
     * @return kotlin.Array<kotlin.Byte>
     */
    @Suppress("UNCHECKED_CAST")
    fun generateContactreportExport(body: kotlin.Array<ByteArray>, date: kotlin.Long, language: kotlin.String, recipientNihii: kotlin.String, recipientSsin: kotlin.String, recipientFirstName: kotlin.String, recipientLastName: kotlin.String, mimeType: kotlin.String, patientId: kotlin.String, id: kotlin.String): kotlin.Array<kotlin.Byte> {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("date" to listOf("$date"), "language" to listOf("$language"), "recipientNihii" to listOf("$recipientNihii"), "recipientSsin" to listOf("$recipientSsin"), "recipientFirstName" to listOf("$recipientFirstName"), "recipientLastName" to listOf("$recipientLastName"), "mimeType" to listOf("$mimeType"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/be_kmehr/contactreport/{patientId}/export/{id}".replace("{" + "patientId" + "}", "$patientId").replace("{" + "id" + "}", "$id"), query = localVariableQuery
        )
        val response = request<kotlin.Array<kotlin.Byte>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<kotlin.Byte>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Generate diarynote
     *
     * @param body
     * @param language
     * @param patientId
     * @return kotlin.Array<kotlin.Byte>
     */
    @Suppress("UNCHECKED_CAST")
    fun generateDiaryNote(body: DiaryNoteExportInfoDto, language: kotlin.String, patientId: kotlin.String): kotlin.Array<kotlin.Byte> {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("language" to listOf("$language"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/be_kmehr/diarynote/{patientId}/export".replace("{" + "patientId" + "}", "$patientId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<kotlin.Byte>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<kotlin.Byte>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get Kmehr labresult
     *
     * @param body
     * @param date
     * @param language
     * @param recipientNihii
     * @param recipientSsin
     * @param recipientFirstName
     * @param recipientLastName
     * @param mimeType
     * @param patientId
     * @param id
     * @return kotlin.Array<kotlin.Byte>
     */
    @Suppress("UNCHECKED_CAST")
    fun generateLabresultExport(body: kotlin.Array<ByteArray>, date: kotlin.Long, language: kotlin.String, recipientNihii: kotlin.String, recipientSsin: kotlin.String, recipientFirstName: kotlin.String, recipientLastName: kotlin.String, mimeType: kotlin.String, patientId: kotlin.String, id: kotlin.String): kotlin.Array<kotlin.Byte> {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("date" to listOf("$date"), "language" to listOf("$language"), "recipientNihii" to listOf("$recipientNihii"), "recipientSsin" to listOf("$recipientSsin"), "recipientFirstName" to listOf("$recipientFirstName"), "recipientLastName" to listOf("$recipientLastName"), "mimeType" to listOf("$mimeType"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/be_kmehr/labresult/{patientId}/export/{id}".replace("{" + "patientId" + "}", "$patientId").replace("{" + "id" + "}", "$id"), query = localVariableQuery
        )
        val response = request<kotlin.Array<kotlin.Byte>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<kotlin.Byte>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get Medicationscheme export
     *
     * @param body
     * @param language
     * @param recipientSafe
     * @param version
     * @param patientId
     * @return kotlin.Array<kotlin.Byte>
     */
    @Suppress("UNCHECKED_CAST")
    fun generateMedicationSchemeExport(body: MedicationSchemeExportInfoDto, language: kotlin.String, recipientSafe: kotlin.String, version: kotlin.Int, patientId: kotlin.String): kotlin.Array<kotlin.Byte> {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("language" to listOf("$language"), "recipientSafe" to listOf("$recipientSafe"), "version" to listOf("$version"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/be_kmehr/medicationscheme/{patientId}/export".replace("{" + "patientId" + "}", "$patientId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<kotlin.Byte>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<kotlin.Byte>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get Kmehr note
     *
     * @param body
     * @param date
     * @param language
     * @param recipientNihii
     * @param recipientSsin
     * @param recipientFirstName
     * @param recipientLastName
     * @param mimeType
     * @param patientId
     * @param id
     * @return kotlin.Array<kotlin.Byte>
     */
    @Suppress("UNCHECKED_CAST")
    fun generateNoteExport(body: kotlin.Array<ByteArray>, date: kotlin.Long, language: kotlin.String, recipientNihii: kotlin.String, recipientSsin: kotlin.String, recipientFirstName: kotlin.String, recipientLastName: kotlin.String, mimeType: kotlin.String, patientId: kotlin.String, id: kotlin.String): kotlin.Array<kotlin.Byte> {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("date" to listOf("$date"), "language" to listOf("$language"), "recipientNihii" to listOf("$recipientNihii"), "recipientSsin" to listOf("$recipientSsin"), "recipientFirstName" to listOf("$recipientFirstName"), "recipientLastName" to listOf("$recipientLastName"), "mimeType" to listOf("$mimeType"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/be_kmehr/note/{patientId}/export/{id}".replace("{" + "patientId" + "}", "$patientId").replace("{" + "id" + "}", "$id"), query = localVariableQuery
        )
        val response = request<kotlin.Array<kotlin.Byte>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<kotlin.Byte>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get Kmehr prescription
     *
     * @param body
     * @param date
     * @param language
     * @param recipientNihii
     * @param recipientSsin
     * @param recipientFirstName
     * @param recipientLastName
     * @param mimeType
     * @param patientId
     * @param id
     * @return kotlin.Array<kotlin.Byte>
     */
    @Suppress("UNCHECKED_CAST")
    fun generatePrescriptionExport(body: kotlin.Array<ByteArray>, date: kotlin.Long, language: kotlin.String, recipientNihii: kotlin.String, recipientSsin: kotlin.String, recipientFirstName: kotlin.String, recipientLastName: kotlin.String, mimeType: kotlin.String, patientId: kotlin.String, id: kotlin.String): kotlin.Array<kotlin.Byte> {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("date" to listOf("$date"), "language" to listOf("$language"), "recipientNihii" to listOf("$recipientNihii"), "recipientSsin" to listOf("$recipientSsin"), "recipientFirstName" to listOf("$recipientFirstName"), "recipientLastName" to listOf("$recipientLastName"), "mimeType" to listOf("$mimeType"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/be_kmehr/prescription/{patientId}/export/{id}".replace("{" + "patientId" + "}", "$patientId").replace("{" + "id" + "}", "$id"), query = localVariableQuery
        )
        val response = request<kotlin.Array<kotlin.Byte>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<kotlin.Byte>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get Kmehr report
     *
     * @param body
     * @param date
     * @param language
     * @param recipientNihii
     * @param recipientSsin
     * @param recipientFirstName
     * @param recipientLastName
     * @param mimeType
     * @param patientId
     * @param id
     * @return kotlin.Array<kotlin.Byte>
     */
    @Suppress("UNCHECKED_CAST")
    fun generateReportExport(body: kotlin.Array<ByteArray>, date: kotlin.Long, language: kotlin.String, recipientNihii: kotlin.String, recipientSsin: kotlin.String, recipientFirstName: kotlin.String, recipientLastName: kotlin.String, mimeType: kotlin.String, patientId: kotlin.String, id: kotlin.String): kotlin.Array<kotlin.Byte> {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("date" to listOf("$date"), "language" to listOf("$language"), "recipientNihii" to listOf("$recipientNihii"), "recipientSsin" to listOf("$recipientSsin"), "recipientFirstName" to listOf("$recipientFirstName"), "recipientLastName" to listOf("$recipientLastName"), "mimeType" to listOf("$mimeType"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/be_kmehr/report/{patientId}/export/{id}".replace("{" + "patientId" + "}", "$patientId").replace("{" + "id" + "}", "$id"), query = localVariableQuery
        )
        val response = request<kotlin.Array<kotlin.Byte>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<kotlin.Byte>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get Kmehr request
     *
     * @param body
     * @param date
     * @param language
     * @param recipientNihii
     * @param recipientSsin
     * @param recipientFirstName
     * @param recipientLastName
     * @param mimeType
     * @param patientId
     * @param id
     * @return kotlin.Array<kotlin.Byte>
     */
    @Suppress("UNCHECKED_CAST")
    fun generateRequestExport(body: kotlin.Array<ByteArray>, date: kotlin.Long, language: kotlin.String, recipientNihii: kotlin.String, recipientSsin: kotlin.String, recipientFirstName: kotlin.String, recipientLastName: kotlin.String, mimeType: kotlin.String, patientId: kotlin.String, id: kotlin.String): kotlin.Array<kotlin.Byte> {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("date" to listOf("$date"), "language" to listOf("$language"), "recipientNihii" to listOf("$recipientNihii"), "recipientSsin" to listOf("$recipientSsin"), "recipientFirstName" to listOf("$recipientFirstName"), "recipientLastName" to listOf("$recipientLastName"), "mimeType" to listOf("$mimeType"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/be_kmehr/request/{patientId}/export/{id}".replace("{" + "patientId" + "}", "$patientId").replace("{" + "id" + "}", "$id"), query = localVariableQuery
        )
        val response = request<kotlin.Array<kotlin.Byte>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<kotlin.Byte>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get Kmehr result
     *
     * @param body
     * @param date
     * @param language
     * @param recipientNihii
     * @param recipientSsin
     * @param recipientFirstName
     * @param recipientLastName
     * @param mimeType
     * @param patientId
     * @param id
     * @return kotlin.Array<kotlin.Byte>
     */
    @Suppress("UNCHECKED_CAST")
    fun generateResultExport(body: kotlin.Array<ByteArray>, date: kotlin.Long, language: kotlin.String, recipientNihii: kotlin.String, recipientSsin: kotlin.String, recipientFirstName: kotlin.String, recipientLastName: kotlin.String, mimeType: kotlin.String, patientId: kotlin.String, id: kotlin.String): kotlin.Array<kotlin.Byte> {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("date" to listOf("$date"), "language" to listOf("$language"), "recipientNihii" to listOf("$recipientNihii"), "recipientSsin" to listOf("$recipientSsin"), "recipientFirstName" to listOf("$recipientFirstName"), "recipientLastName" to listOf("$recipientLastName"), "mimeType" to listOf("$mimeType"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/be_kmehr/result/{patientId}/export/{id}".replace("{" + "patientId" + "}", "$patientId").replace("{" + "id" + "}", "$id"), query = localVariableQuery
        )
        val response = request<kotlin.Array<kotlin.Byte>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<kotlin.Byte>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get SMF (Software Medical File) export
     *
     * @param body
     * @param language
     * @param patientId
     * @return kotlin.Array<kotlin.Byte>
     */
    @Suppress("UNCHECKED_CAST")
    fun generateSmfExport(body: SoftwareMedicalFileExportDto, language: kotlin.String, patientId: kotlin.String): kotlin.Array<kotlin.Byte> {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("language" to listOf("$language"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/be_kmehr/smf/{patientId}/export".replace("{" + "patientId" + "}", "$patientId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<kotlin.Byte>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<kotlin.Byte>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Generate sumehr
     *
     * @param body
     * @param language
     * @param patientId
     * @return kotlin.Array<kotlin.Byte>
     */
    @Suppress("UNCHECKED_CAST")
    fun generateSumehr(body: SumehrExportInfoDto, language: kotlin.String, patientId: kotlin.String): kotlin.Array<kotlin.Byte> {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("language" to listOf("$language"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/be_kmehr/sumehr/{patientId}/export".replace("{" + "patientId" + "}", "$patientId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<kotlin.Byte>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<kotlin.Byte>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Generate sumehr
     *
     * @param body
     * @param language
     * @param patientId
     * @return kotlin.Array<kotlin.Byte>
     */
    @Suppress("UNCHECKED_CAST")
    fun generateSumehrV2(body: SumehrExportInfoDto, language: kotlin.String, patientId: kotlin.String): kotlin.Array<kotlin.Byte> {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("language" to listOf("$language"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/be_kmehr/sumehrv2/{patientId}/export".replace("{" + "patientId" + "}", "$patientId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<kotlin.Byte>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<kotlin.Byte>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get sumehr elements
     *
     * @param body
     * @param patientId
     * @return SumehrContentDto
     */
    @Suppress("UNCHECKED_CAST")
    fun getSumehrContent(body: SumehrExportInfoDto, patientId: kotlin.String): SumehrContentDto {
        val localVariableBody: kotlin.Any? = body

        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/be_kmehr/sumehr/{patientId}/content".replace("{" + "patientId" + "}", "$patientId")
        )
        val response = request<SumehrContentDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as SumehrContentDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Check sumehr signature
     *
     * @param body
     * @param patientId
     * @return ContentDto
     */
    @Suppress("UNCHECKED_CAST")
    fun getSumehrMd5(body: SumehrExportInfoDto, patientId: kotlin.String): ContentDto {
        val localVariableBody: kotlin.Any? = body

        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/be_kmehr/sumehr/{patientId}/md5".replace("{" + "patientId" + "}", "$patientId")
        )
        val response = request<ContentDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ContentDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get sumehr elements
     *
     * @param body
     * @param patientId
     * @return SumehrContentDto
     */
    @Suppress("UNCHECKED_CAST")
    fun getSumehrV2Content(body: SumehrExportInfoDto, patientId: kotlin.String): SumehrContentDto {
        val localVariableBody: kotlin.Any? = body

        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/be_kmehr/sumehrv2/{patientId}/content".replace("{" + "patientId" + "}", "$patientId")
        )
        val response = request<SumehrContentDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as SumehrContentDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Check sumehr signature
     *
     * @param body
     * @param patientId
     * @return ContentDto
     */
    @Suppress("UNCHECKED_CAST")
    fun getSumehrV2Md5(body: SumehrExportInfoDto, patientId: kotlin.String): ContentDto {
        val localVariableBody: kotlin.Any? = body

        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/be_kmehr/sumehrv2/{patientId}/md5".replace("{" + "patientId" + "}", "$patientId")
        )
        val response = request<ContentDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ContentDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Import MedicationScheme into patient(s) using existing document
     *
     * @param body
     * @param documentId
     * @param documentKey  (optional)
     * @param dryRun Dry run: do not save in database (optional)
     * @param patientId  (optional)
     * @param language  (optional)
     * @return kotlin.Array<ImportResultDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun importMedicationScheme(body: kotlin.collections.Map<kotlin.String, kotlin.Array<ImportMapping>>, documentId: kotlin.String, documentKey: kotlin.String? = null, dryRun: kotlin.Boolean? = null, patientId: kotlin.String? = null, language: kotlin.String? = null): kotlin.Array<ImportResultDto> {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("documentKey" to listOf("$documentKey"), "dryRun" to listOf("$dryRun"), "patientId" to listOf("$patientId"), "language" to listOf("$language"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/be_kmehr/medicationscheme/{documentId}/import".replace("{" + "documentId" + "}", "$documentId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<ImportResultDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<ImportResultDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Import SMF into patient(s) using existing document
     *
     * @param body
     * @param documentId
     * @param documentKey  (optional)
     * @param patientId  (optional)
     * @param language  (optional)
     * @return kotlin.Array<ImportResultDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun importSmf(body: kotlin.collections.Map<kotlin.String, kotlin.Array<ImportMapping>>, documentId: kotlin.String, documentKey: kotlin.String? = null, patientId: kotlin.String? = null, language: kotlin.String? = null): kotlin.Array<ImportResultDto> {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("documentKey" to listOf("$documentKey"), "patientId" to listOf("$patientId"), "language" to listOf("$language"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/be_kmehr/smf/{documentId}/import".replace("{" + "documentId" + "}", "$documentId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<ImportResultDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<ImportResultDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Import sumehr into patient(s) using existing document
     *
     * @param body
     * @param documentId
     * @param documentKey  (optional)
     * @param dryRun Dry run: do not save in database (optional)
     * @param patientId  (optional)
     * @param language  (optional)
     * @return kotlin.Array<ImportResultDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun importSumehr(body: kotlin.collections.Map<kotlin.String, kotlin.Array<ImportMapping>>, documentId: kotlin.String, documentKey: kotlin.String? = null, dryRun: kotlin.Boolean? = null, patientId: kotlin.String? = null, language: kotlin.String? = null): kotlin.Array<ImportResultDto> {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("documentKey" to listOf("$documentKey"), "dryRun" to listOf("$dryRun"), "patientId" to listOf("$patientId"), "language" to listOf("$language"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/be_kmehr/sumehr/{documentId}/import".replace("{" + "documentId" + "}", "$documentId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<ImportResultDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<ImportResultDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Import sumehr into patient(s) using existing document
     *
     * @param body
     * @param itemId
     * @param documentId
     * @param documentKey  (optional)
     * @param dryRun Dry run: do not save in database (optional)
     * @param patientId  (optional)
     * @param language  (optional)
     * @return kotlin.Array<ImportResultDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun importSumehrByItemId(body: kotlin.collections.Map<kotlin.String, kotlin.Array<ImportMapping>>, itemId: kotlin.String, documentId: kotlin.String, documentKey: kotlin.String? = null, dryRun: kotlin.Boolean? = null, patientId: kotlin.String? = null, language: kotlin.String? = null): kotlin.Array<ImportResultDto> {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("itemId" to listOf("$itemId"), "documentKey" to listOf("$documentKey"), "dryRun" to listOf("$dryRun"), "patientId" to listOf("$patientId"), "language" to listOf("$language"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/be_kmehr/sumehr/{documentId}/importbyitemid".replace("{" + "documentId" + "}", "$documentId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<ImportResultDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<ImportResultDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get sumehr validity
     *
     * @param body
     * @param patientId
     * @return SumehrValidityDto
     */
    @Suppress("UNCHECKED_CAST")
    fun isSumehrV2Valid(body: SumehrExportInfoDto, patientId: kotlin.String): SumehrValidityDto {
        val localVariableBody: kotlin.Any? = body

        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/be_kmehr/sumehrv2/{patientId}/valid".replace("{" + "patientId" + "}", "$patientId")
        )
        val response = request<SumehrValidityDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as SumehrValidityDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get sumehr validity
     *
     * @param body
     * @param patientId
     * @return SumehrValidityDto
     */
    @Suppress("UNCHECKED_CAST")
    fun isSumehrValid(body: SumehrExportInfoDto, patientId: kotlin.String): SumehrValidityDto {
        val localVariableBody: kotlin.Any? = body

        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/be_kmehr/sumehr/{patientId}/valid".replace("{" + "patientId" + "}", "$patientId")
        )
        val response = request<SumehrValidityDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as SumehrValidityDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Validate sumehr
     *
     * @param body
     * @param language
     * @param patientId
     * @return kotlin.Array<kotlin.Byte>
     */
    @Suppress("UNCHECKED_CAST")
    fun validateSumehr(body: SumehrExportInfoDto, language: kotlin.String, patientId: kotlin.String): kotlin.Array<kotlin.Byte> {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("language" to listOf("$language"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/be_kmehr/sumehr/{patientId}/validate".replace("{" + "patientId" + "}", "$patientId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<kotlin.Byte>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<kotlin.Byte>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Validate sumehr
     *
     * @param body
     * @param language
     * @param patientId
     * @return kotlin.Array<kotlin.Byte>
     */
    @Suppress("UNCHECKED_CAST")
    fun validateSumehrV2(body: SumehrExportInfoDto, language: kotlin.String, patientId: kotlin.String): kotlin.Array<kotlin.Byte> {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mapOf("language" to listOf("$language"))
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/be_kmehr/sumehrv2/{patientId}/validate".replace("{" + "patientId" + "}", "$patientId"), query = localVariableQuery
        )
        val response = request<kotlin.Array<kotlin.Byte>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<kotlin.Byte>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
}
