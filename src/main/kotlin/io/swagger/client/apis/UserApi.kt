/**
 * iCure Cloud API Documentation
 * Spring shop sample application
 *
 * OpenAPI spec version: v0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import io.swagger.client.models.DocIdentifier
import io.swagger.client.models.EmailTemplateDto
import io.swagger.client.models.PaginatedListUserDto
import io.swagger.client.models.PropertyStubDto
import io.swagger.client.models.UserDto
import io.swagger.client.models.UserGroupDto

import io.swagger.client.infrastructure.*

class UserApi(basePath: kotlin.String = "https://kraken.icure.dev") : ApiClient(basePath) {

    /**
     * Assign a healthcare party ID to current user
     * UserDto gets returned.
     * @param healthcarePartyId
     * @return UserDto
     */
    @Suppress("UNCHECKED_CAST")
    fun assignHealthcareParty(healthcarePartyId: kotlin.String): UserDto {

        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/rest/v1/user/current/hcparty/{healthcarePartyId}".replace("{" + "healthcarePartyId" + "}", "$healthcarePartyId")
        )
        val response = request<UserDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as UserDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     *
     *
     * @param password
     * @return kotlin.Boolean
     */
    @Suppress("UNCHECKED_CAST")
    fun checkPassword(password: kotlin.String): kotlin.Boolean {

        val localVariableHeaders: kotlin.collections.Map<kotlin.String, kotlin.String> = mapOf("password" to password)
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/user/checkPassword", headers = localVariableHeaders
        )
        val response = request<kotlin.Boolean>(
                localVariableConfig, null
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Boolean
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Create a user
     * Create a user. HealthcareParty ID should be set. Email has to be set and the Login has to be null. On server-side, Email will be used for Login.
     * @param body
     * @return UserDto
     */
    @Suppress("UNCHECKED_CAST")
    fun createUser(body: UserDto): UserDto {
        val localVariableBody: kotlin.Any? = body

        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/user"
        )
        val response = request<UserDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as UserDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Create a user
     * Create a user. HealthcareParty ID should be set. Email has to be set and the Login has to be null. On server-side, Email will be used for Login.
     * @param body
     * @param groupId
     * @return UserDto
     */
    @Suppress("UNCHECKED_CAST")
    fun createUserInGroup(body: UserDto, groupId: kotlin.String): UserDto {
        val localVariableBody: kotlin.Any? = body

        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/user/inGroup/{groupId}".replace("{" + "groupId" + "}", "$groupId")
        )
        val response = request<UserDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as UserDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Delete a User based on his/her ID.
     * Delete a User based on his/her ID. The return value is an array containing the ID of deleted user.
     * @param userId
     * @return DocIdentifier
     */
    @Suppress("UNCHECKED_CAST")
    fun deleteUser(userId: kotlin.String): DocIdentifier {

        val localVariableConfig = RequestConfig(
                RequestMethod.DELETE,
                "/rest/v1/user/{userId}".replace("{" + "userId" + "}", "$userId")
        )
        val response = request<DocIdentifier>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as DocIdentifier
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Delete a User based on his/her ID.
     * Delete a User based on his/her ID. The return value is an array containing the ID of deleted user.
     * @param groupId
     * @param userId
     * @return Unit
     */
    @Suppress("UNCHECKED_CAST")
    fun deleteUserInGroup(groupId: kotlin.String, userId: kotlin.String): Unit {

        val localVariableConfig = RequestConfig(
                RequestMethod.DELETE,
                "/rest/v1/user/inGroup/{groupId}/{userId}".replace("{" + "groupId" + "}", "$groupId").replace("{" + "userId" + "}", "$userId")
        )
        val response = request<Unit>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     *
     *
     * @param password
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    fun encodePassword(password: kotlin.String): kotlin.String {

        val localVariableHeaders: kotlin.collections.Map<kotlin.String, kotlin.String> = mapOf("password" to password)
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/user/encodePassword", headers = localVariableHeaders
        )
        val response = request<kotlin.String>(
                localVariableConfig, null
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.String
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get the list of users by healthcare party id
     *
     * @param id
     * @return kotlin.Array<kotlin.String>
     */
    @Suppress("UNCHECKED_CAST")
    fun findByHcpartyId(id: kotlin.String): kotlin.Array<kotlin.String> {

        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/user/byHealthcarePartyId/{id}".replace("{" + "id" + "}", "$id")
        )
        val response = request<kotlin.Array<kotlin.String>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<kotlin.String>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Send a forgotten email message to an user
     *
     * @param body
     * @param email the email of the user
     * @return kotlin.Boolean
     */
    @Suppress("UNCHECKED_CAST")
    fun forgottenPassword(body: EmailTemplateDto, email: kotlin.String): kotlin.Boolean {
        val localVariableBody: kotlin.Any? = body

        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/rest/v1/user/forgottenPassword/{email}".replace("{" + "email" + "}", "$email")
        )
        val response = request<kotlin.Boolean>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Boolean
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get Currently logged-in user session.
     * Get current user.
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    fun getCurrentSession(): kotlin.String {

        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/user/session"
        )
        val response = request<kotlin.String>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.String
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get presently logged-in user.
     * Get current user.
     * @return UserDto
     */
    @Suppress("UNCHECKED_CAST")
    fun getCurrentUser(): UserDto {

        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/user/current"
        )
        val response = request<UserDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as UserDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get presently logged-in user.
     * Get current user.
     * @return kotlin.Array<UserGroupDto>
     */
    @Suppress("UNCHECKED_CAST")
    fun getMatchingUsers(): kotlin.Array<UserGroupDto> {

        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/user/matches"
        )
        val response = request<kotlin.Array<UserGroupDto>>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<UserGroupDto>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get a user by his ID
     * General information about the user
     * @param userId
     * @return UserDto
     */
    @Suppress("UNCHECKED_CAST")
    fun getUser(userId: kotlin.String): UserDto {

        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/user/{userId}".replace("{" + "userId" + "}", "$userId")
        )
        val response = request<UserDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as UserDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Get a user by his Email/Login
     * General information about the user
     * @param email
     * @return UserDto
     */
    @Suppress("UNCHECKED_CAST")
    fun getUserByEmail(email: kotlin.String): UserDto {

        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/user/byEmail/{email}".replace("{" + "email" + "}", "$email")
        )
        val response = request<UserDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as UserDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * List users with(out) pagination
     * Returns a list of users.
     * @param startKey An user email (optional)
     * @param startDocumentId An user document ID (optional)
     * @param limit Number of rows (optional)
     * @return PaginatedListUserDto
     */
    @Suppress("UNCHECKED_CAST")
    fun listUsers(startKey: kotlin.String? = null, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null): PaginatedListUserDto {
        val localVariableQuery: MultiValueMap = mapOf("startKey" to listOf("$startKey"), "startDocumentId" to listOf("$startDocumentId"), "limit" to listOf("$limit"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/user", query = localVariableQuery
        )
        val response = request<PaginatedListUserDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as PaginatedListUserDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * List users with(out) pagination
     * Returns a list of users.
     * @param groupId
     * @param startKey An user login (optional)
     * @param startDocumentId An user document ID (optional)
     * @param limit Number of rows (optional)
     * @return PaginatedListUserDto
     */
    @Suppress("UNCHECKED_CAST")
    fun listUsersInGroup(groupId: kotlin.String, startKey: kotlin.String? = null, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null): PaginatedListUserDto {
        val localVariableQuery: MultiValueMap = mapOf("startKey" to listOf("$startKey"), "startDocumentId" to listOf("$startDocumentId"), "limit" to listOf("$limit"))
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/rest/v1/user/inGroup/{groupId}".replace("{" + "groupId" + "}", "$groupId"), query = localVariableQuery
        )
        val response = request<PaginatedListUserDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as PaginatedListUserDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Modify a User property
     * Modify a User properties based on his/her ID. The return value is the modified user.
     * @param body
     * @param userId
     * @return UserDto
     */
    @Suppress("UNCHECKED_CAST")
    fun modifyProperties(body: kotlin.Array<PropertyStubDto>, userId: kotlin.String): UserDto {
        val localVariableBody: kotlin.Any? = body

        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/rest/v1/user/{userId}/properties".replace("{" + "userId" + "}", "$userId")
        )
        val response = request<UserDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as UserDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Modify a user.
     * No particular return value. It&#x27;s just a message.
     * @param body
     * @return UserDto
     */
    @Suppress("UNCHECKED_CAST")
    fun modifyUser(body: UserDto): UserDto {
        val localVariableBody: kotlin.Any? = body

        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/rest/v1/user"
        )
        val response = request<UserDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as UserDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Modify a user.
     * No particular return value. It&#x27;s just a message.
     * @param body
     * @param groupId
     * @return UserDto
     */
    @Suppress("UNCHECKED_CAST")
    fun modifyUserInGroup(body: UserDto, groupId: kotlin.String): UserDto {
        val localVariableBody: kotlin.Any? = body

        val localVariableConfig = RequestConfig(
                RequestMethod.PUT,
                "/rest/v1/user/inGroup/{groupId}".replace("{" + "groupId" + "}", "$groupId")
        )
        val response = request<UserDto>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as UserDto
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
}
